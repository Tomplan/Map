#!/usr/bin/env node
/**
 * Scan companies and markers_content for generated logo filenames whose
 * basename starts with digits or looks like an autogenerated numeric token
 * (e.g. "1762803399988_po4ce0.png") and normalize them to slugified
 * basenames derived from the company/marker name.
 *
 * Usage (dry-run):
 *   SUPABASE_URL=... SUPABASE_SERVICE_ROLE_KEY=... node scripts/normalize-numeric-generated.mjs
 *
 * To apply changes (copy generated variants + update rows) add --confirm
 */

import { createClient } from '@supabase/supabase-js';
import path from 'path';

const url = process.env.SUPABASE_URL;
const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
if (!url || !key) {
  console.error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
  process.exit(2);
}

const supabase = createClient(url, key, { auth: { persistSession: false } });
const confirm = process.argv.includes('--confirm');
const BUCKET = 'Logos';
const SIZES = [64, 128, 256, 512];
const VARIANT_EXTS = ['.webp', '.avif'];

import { slugify } from './lib/logoUtils.js';

function cdnUrlFor(filename) {
  const base = url.replace(/\/$/, '');
  return `${base}/storage/v1/object/public/Logos/generated/${encodeURIComponent(filename)}`;
}

function looksNumericBase(basename) {
  // Detect basenames beginning with a long digit sequence (timestamp-ish) or containing a numeric prefix
  return /^\d+[_-]/.test(basename) || /^\d{8,}$/.test(basename);
}

async function listNumericCompanyCandidates(limit = 2000) {
  // Find companies where logo points to generated/ and basename starts with digits
  const { data, error } = await supabase
    .from('companies')
    .select('id, name, logo')
    .ilike('logo', '%/Logos/generated/%')
    .limit(limit);
  if (error) throw error;

  return (data || []).filter((r) => {
    const filename = String(r.logo || '').split('/').pop();
    const base = filename ? filename.replace(/\.[^.]+$/, '') : '';
    return base && looksNumericBase(base);
  });
}

async function listNumericMarkerCandidates(limit = 2000) {
  // markers_content has id, logo, name (some variations) - fetch if available
  const { data, error } = await supabase
    .from('markers_content')
    .select('id, logo, name, event_year')
    .ilike('logo', '%/Logos/generated/%')
    .limit(limit);
  if (error) throw error;

  return (data || []).filter(r => {
    const filename = String(r.logo || '').split('/').pop();
    const base = filename ? filename.replace(/\.[^.]+$/, '') : '';
    return base && looksNumericBase(base);
  });
}

async function objectExists(remotePath) {
  const listRes = await supabase.storage.from(BUCKET).list(path.dirname(remotePath), { limit: 2000 });
  if (listRes.error) return false;
  return listRes.data.some(o => o.name === path.basename(remotePath));
}

async function downloadToBuffer(remotePath) {
  const { data, error } = await supabase.storage.from(BUCKET).download(remotePath);
  if (error) return { error };
  if (data.arrayBuffer) {
    const ab = await data.arrayBuffer();
    return { buffer: Buffer.from(ab) };
  } else if (data instanceof Buffer) {
    return { buffer: data };
  } else if (data.stream) {
    const stream = await data.stream();
    const chunks = [];
    for await (const c of stream) chunks.push(c);
    return { buffer: Buffer.concat(chunks) };
  }
  try { const text = await data.text(); return { buffer: Buffer.from(text) }; } catch (e) { return { error: e } }
}

function contentTypeForExt(ext) {
  if (!ext) return 'application/octet-stream';
  const e = ext.toLowerCase();
  if (e === '.webp') return 'image/webp';
  if (e === '.avif') return 'image/avif';
  if (e === '.png') return 'image/png';
  if (e === '.jpg' || e === '.jpeg') return 'image/jpeg';
  return 'application/octet-stream';
}

async function copyGeneratedVariants(srcBase, dstBase) {
  // For each size and ext, copy generated/<srcBase>-<size>.<ext> -> generated/<dstBase>-<size>.<ext>
  const results = [];
  for (const size of SIZES) {
    for (const ext of VARIANT_EXTS) {
      const srcName = `generated/${srcBase}-${size}${ext}`;
      const dstName = `generated/${dstBase}-${size}${ext}`;

      const { buffer, error } = await downloadToBuffer(srcName);
      if (error || !buffer) {
        results.push({ srcName, dstName, success: false, reason: 'missing' });
        continue;
      }

      const up = await supabase.storage.from(BUCKET).upload(dstName, buffer, { upsert: true, contentType: contentTypeForExt(ext) });
      if (up.error) results.push({ srcName, dstName, success: false, reason: up.error.message || up.error });
      else results.push({ srcName, dstName, success: true });
    }
  }
  return results;
}

async function findUniqueBase(desired) {
  // Ensure we don't collide with an existing generated basename; append suffixes if needed
  let candidate = desired;
  let i = 1;
  while (true) {
    // check if generated/<candidate>-128.webp exists (proxy check)
    const testRemote = `generated/${candidate}-128.webp`;
    const exists = await objectExists(testRemote);
    if (!exists) return candidate;
    candidate = `${desired}-${i}`;
    i += 1;
  }
}

async function processCompanies(confirmApply = false) {
  const candidates = await listNumericCompanyCandidates();
  if (!candidates.length) return [];

  const planned = [];
  for (const r of candidates) {
    const filename = String(r.logo).split('/').pop();
    const base = filename.replace(/\.[^.]+$/, '');
    const ext = path.extname(filename) || '.png';
    const desired = slugify(r.name || `company-${r.id}`);
    const uniqueBase = await findUniqueBase(desired);
    planned.push({ table: 'companies', id: r.id, name: r.name, oldBase: base, oldFilename: filename, oldExt: ext, desiredBase: uniqueBase, desiredFilename: `${uniqueBase}${ext}` });
  }

  if (!confirmApply) return planned;

  // apply: copy variants and update DB
  for (const p of planned) {
    console.log(`Applying for company ${p.id}: ${p.oldBase} -> ${p.desiredBase}`);
    const res = await copyGeneratedVariants(p.oldBase, p.desiredBase);
    const newUrl = cdnUrlFor(p.desiredFilename);
    const upd = await supabase.from('companies').update({ logo: newUrl }).eq('id', p.id);
    if (upd.error) console.error('Failed update DB for company', p.id, upd.error.message || upd.error);
    else console.log('Updated company', p.id, '->', newUrl);
  }

  return planned;
}

async function processMarkers(confirmApply = false) {
  const candidates = await listNumericMarkerCandidates();
  if (!candidates.length) return [];

  const planned = [];
  for (const r of candidates) {
    const filename = String(r.logo).split('/').pop();
    const base = filename.replace(/\.[^.]+$/, '');
    const ext = path.extname(filename) || '.png';
    const desiredSeed = r.name ? slugify(r.name) : `marker-${r.id}`;
    const uniqueBase = await findUniqueBase(desiredSeed);
    planned.push({ table: 'markers_content', id: r.id, name: r.name, event_year: r.event_year, oldBase: base, oldFilename: filename, oldExt: ext, desiredBase: uniqueBase, desiredFilename: `${uniqueBase}${ext}` });
  }

  if (!confirmApply) return planned;

  for (const p of planned) {
    console.log(`Applying for marker_content ${p.id}: ${p.oldBase} -> ${p.desiredBase}`);
    await copyGeneratedVariants(p.oldBase, p.desiredBase);
    const newUrl = cdnUrlFor(p.desiredFilename);
    const upd = await supabase.from('markers_content').update({ logo: newUrl }).eq('id', p.id);
    if (upd.error) console.error('Failed update DB for marker', p.id, upd.error.message || upd.error);
    else console.log('Updated markers_content', p.id, '->', newUrl);
  }

  return planned;
}

async function main() {
  console.log('Scanning for numeric-generated logos in companies and markers_content...');
  try {
    const companyPlan = await processCompanies(false);
    const markerPlan = await processMarkers(false);

    if (companyPlan.length === 0 && markerPlan.length === 0) {
      console.log('No numeric-generated logo rows found. Nothing to do.');
      return;
    }

    console.log('\nPlanned company updates:');
    console.table(companyPlan.map(p => ({ id: p.id, name: p.name, from: p.oldBase, to: p.desiredBase, newFilename: p.desiredFilename })));

    console.log('\nPlanned marker_content updates:');
    console.table(markerPlan.map(p => ({ id: p.id, name: p.name, event_year: p.event_year, from: p.oldBase, to: p.desiredBase, newFilename: p.desiredFilename })));

    if (!confirm) {
      console.log('\nDRY RUN - no changes applied. Re-run with --confirm to copy variants and update DB.');
      return;
    }

    console.log('\nApplying changes (this may upload new objects)');
    await processCompanies(true);
    await processMarkers(true);

    console.log('\nDone.');
  } catch (err) {
    console.error('Error during normalization scan:', err.message || err);
    process.exit(1);
  }
}

main();
